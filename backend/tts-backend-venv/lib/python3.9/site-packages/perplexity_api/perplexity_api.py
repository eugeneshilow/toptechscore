import os
import time
import re

import urllib
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import markdownify
from bs4 import BeautifulSoup

FOCUS = {"internet": 1, "academic":2, "writing":3, "youtube":5, "reddit":6, "wikipedia":7} # "wolfram":4 requires sign-up

def debug(*args):
    if "DEBUG" in os.environ:
        print(*args)

class PerplexityAPI:
    def __init__(self, headless=True, user_agent=None, timeout=10, response_timeout=30):
        options = Options()
        if headless:
            options.add_argument("--headless")
        if user_agent:
            options.add_argument(f"user-agent={user_agent}")
        self.driver = webdriver.Chrome(options=options)
        self.timeout = timeout
        self.response_timeout = response_timeout
        #print("User-Agent:", self.driver.execute_script("return navigator.userAgent"))

    def query(self, prompt, follow_up=False, focus="internet"):
        if focus not in FOCUS:
            raise ValueError("unknown focus,", focus)
        if not follow_up: # self.driver.current_url == "data:,"
            self.driver.get(f"https://www.perplexity.ai")
            WebDriverWait(self.driver, self.timeout).until(EC.visibility_of_element_located((By.TAG_NAME, "body")))
            self.driver.find_elements(By.CSS_SELECTOR, "textarea")[0].click()
            
            if focus != "internet":
                for i in range(2): # re-try in case of random sign-up screens
                    WebDriverWait(self.driver, self.timeout).until(lambda driver: len(driver.find_elements(By.CSS_SELECTOR, "button")) >= 7)
                    self.driver.find_elements(By.CSS_SELECTOR, "button")[6].click()
                    if len(self.driver.find_elements(By.CSS_SELECTOR, ".top-sm button")):
                        time.sleep(0.25)
                        self.driver.find_elements(By.CSS_SELECTOR, ".top-sm button")[0].click()
                        time.sleep(0.25)
                        continue
                    time.sleep(0.25)
                    WebDriverWait(self.driver, self.timeout).until(lambda driver: len(driver.find_elements(By.CSS_SELECTOR, ".cursor-pointer")) >= 4)
                    self.driver.find_elements(By.CSS_SELECTOR, ".cursor-pointer")[FOCUS[focus]].click()
                    if len(self.driver.find_elements(By.CSS_SELECTOR, ".top-sm button")):
                        time.sleep(0.25)
                        self.driver.find_elements(By.CSS_SELECTOR, ".top-sm button")[0].click()
                        time.sleep(0.25)
                        continue
                    break
        
        textarea = self.driver.find_elements(By.CSS_SELECTOR, "textarea")[0]
        textarea.send_keys(prompt)
        textarea.send_keys(Keys.ENTER)

        try:
            wait = WebDriverWait(self.driver, self.timeout)
            count = len(self.driver.find_elements(By.CSS_SELECTOR, ".mb-md .-ml-sm")) + 1
            wait.until(lambda driver: len(driver.find_elements(By.CSS_SELECTOR, ".prose")) == count)
        except TimeoutException:
            raise TimeoutException("Query timeout")
            return

        try:
            wait = WebDriverWait(self.driver, self.response_timeout)
            wait.until(
                (lambda driver: len(driver.find_elements(By.CSS_SELECTOR, ".mb-md .-ml-sm")) == count and
                EC.visibility_of(driver.find_elements(By.CSS_SELECTOR, ".mb-md .-ml-sm")[count-1]))
            )
            time.sleep(0.25)
        except TimeoutException:
            raise TimeoutException("Response timeout")
            return

        element = self.driver.find_elements(By.CSS_SELECTOR, ".pb-md")[-1]
        #query = element.find_elements(By.CSS_SELECTOR, ".text-xl")[0].get_attribute("innerText") # nn

        text = element.find_elements(By.CSS_SELECTOR, ".prose")[0]
        html = text.get_attribute("innerHTML")
        soup = BeautifulSoup(html, "html.parser")
        for el in soup.select("span.text-\\[0\\.60rem\\]") + soup.select("a"):
            el.decompose()

        for el in soup.select(".text-textMainDark"):
            el.replace_with(el.text + "\n")

        for el in soup.select(".codeWrapper"):
            el.name = "tt"
            #el.insert_before(soup.new_tag("br"))
            el.replace_with(el.text)

        debug("==DEBUG==\n", soup.decode())
        response = markdownify.markdownify(soup.decode(), strip=["a", "img", "code", "span"]).strip()

        # clean up pre code blocks
        response = re.sub(r"```\n(?=[^\n])", "```", response)
        response = re.sub(r"(?<=[^:])\n\n```", "\n```", response)
        response = response.replace("\n\n\n```\n", "```")
        response = response.replace("\n\n```", "\n```")
        response = response.replace("\n\n```", "\n```")
        response = response.replace("```\n\n", "```\n")

        debug("==RESPONSE==\n", response)

        # clean up line breaks
        response = re.sub("\n\n\n+", "\n\n", response)

        return response

    def quit(self):
        self.driver.quit()

def test():
    ppl = PerplexityAPI()
    queries = [
        "hello world in python",
        "and in c++",
    ]
    for i, query in enumerate(queries):
        if i > 0:
            print("***")
        print(query)
        print("***")
        print(ppl.query(query, follow_up=True))
    ppl.quit()

if __name__ == "__main__":   
    from argparse import ArgumentParser    

    p = ArgumentParser()
    p.add_argument("--show-chrome", action="store_true", help="show chrome while running (for debugging)")
    args = p.parse_args()

    YELLOW = "\033[1;33m"
    ENDC = "\033[0m"
    
    print("Enter a query:\n")
    ppl = PerplexityAPI(headless=not args.show_chrome)
    query = None
    while query != "":
        try:
            query = input(YELLOW)
        except KeyboardInterrupt:
            print(ENDC)
            raise SystemExit
        print(f"{ENDC}***")
        try:
            response = ppl.query(query, follow_up=True)
            print(response)
            print("***")
        except TimeoutException:
            print("Query timed out.")